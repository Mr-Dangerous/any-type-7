<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ship Visual Processor - Any-Type-7</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            color: #eee;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            color: #4a9eff;
            margin-bottom: 20px;
            text-align: center;
        }

        .section {
            background: #16213e;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .section h2 {
            color: #4a9eff;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .file-input-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="file"] {
            padding: 10px;
            background: #0f3460;
            border: 2px solid #4a9eff;
            border-radius: 4px;
            color: #eee;
            cursor: pointer;
        }

        select {
            padding: 10px;
            background: #0f3460;
            border: 2px solid #4a9eff;
            border-radius: 4px;
            color: #eee;
            cursor: pointer;
            min-width: 200px;
        }

        .ship-info {
            margin-top: 10px;
            padding: 10px;
            background: #0f3460;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-size: 0.9em;
            color: #aaa;
        }

        input[type="range"] {
            width: 100%;
        }

        input[type="text"] {
            padding: 8px;
            background: #0f3460;
            border: 2px solid #4a9eff;
            border-radius: 4px;
            color: #eee;
        }

        input[type="checkbox"] {
            margin-right: 5px;
        }

        .canvas-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            background: #0f3460;
            border-radius: 4px;
            padding: 20px;
            overflow: auto;
            min-height: 400px;
        }

        canvas {
            border: 2px solid #4a9eff;
            cursor: crosshair;
            image-rendering: pixelated;
        }

        .point-list {
            list-style: none;
            max-height: 300px;
            overflow-y: auto;
        }

        .point-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background: #0f3460;
            margin-bottom: 5px;
            border-radius: 4px;
        }

        .point-item:hover {
            background: #1a4d7a;
        }

        .point-label {
            font-weight: bold;
            color: #4a9eff;
        }

        .point-coords {
            color: #aaa;
            font-family: monospace;
        }

        .point-remove {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
        }

        .point-remove:hover {
            background: #c0392b;
        }

        button {
            padding: 10px 20px;
            background: #4a9eff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
        }

        button:hover {
            background: #357abd;
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
        }

        .preset-btn {
            background: #2c5f7a;
            font-size: 0.8em;
        }

        .preset-btn:hover {
            background: #3a7a9a;
        }

        .preset-btn.active {
            background: #4a9eff;
            border: 2px solid #fff;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        #status {
            padding: 10px;
            background: #0f3460;
            border-left: 4px solid #4a9eff;
            border-radius: 4px;
            font-family: monospace;
        }

        .status-success {
            border-left-color: #2ecc71 !important;
            color: #2ecc71;
        }

        .status-error {
            border-left-color: #e74c3c !important;
            color: #e74c3c;
        }

        .zoom-display {
            font-weight: bold;
            color: #4a9eff;
        }

        .grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
        }

        @media (max-width: 1024px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üöÄ Ship Visual Processor</h1>

        <!-- CSV Load Section -->
        <div class="section">
            <h2>1. Load Ship Data</h2>
            <div class="file-input-wrapper">
                <input type="file" id="csvInput" accept=".csv">
                <span id="csvStatus">No CSV loaded</span>
            </div>
        </div>

        <!-- Ship Selection Section -->
        <div class="section">
            <h2>2. Select Ship</h2>
            <select id="shipSelect" disabled>
                <option value="">Load CSV first...</option>
            </select>
            <div id="shipInfo" class="ship-info" style="display:none;"></div>
        </div>

        <div class="grid">
            <!-- Canvas Section -->
            <div>
                <!-- Controls Section -->
                <div class="section">
                    <h2>3. View Controls</h2>
                    <div class="controls">
                        <div class="control-group">
                            <label>Zoom: <span id="zoomLevel" class="zoom-display">100%</span></label>
                            <input type="range" id="zoomSlider" min="25" max="800" value="100" step="25">
                        </div>
                        <div class="control-group">
                            <label>
                                <input type="checkbox" id="gridToggle">
                                Show Pixel Grid
                            </label>
                        </div>
                        <div class="control-group">
                            <label>Point Label Presets</label>
                            <div style="display: flex; flex-wrap: wrap; gap: 3px; margin-bottom: 5px;">
                                <button class="preset-btn" data-label="projectile_odd_row_1" style="padding: 3px 6px; font-size: 0.8em;">P_Odd_1</button>
                                <button class="preset-btn" data-label="projectile_odd_row_2" style="padding: 3px 6px; font-size: 0.8em;">P_Odd_2</button>
                                <button class="preset-btn" data-label="projectile_odd_row_3" style="padding: 3px 6px; font-size: 0.8em;">P_Odd_3</button>
                                <button class="preset-btn" data-label="projectile_even_row_1" style="padding: 3px 6px; font-size: 0.8em;">P_Even_1</button>
                                <button class="preset-btn" data-label="projectile_even_row_2" style="padding: 3px 6px; font-size: 0.8em;">P_Even_2</button>
                                <button class="preset-btn" data-label="projectile_even_row_3" style="padding: 3px 6px; font-size: 0.8em;">P_Even_3</button>
                                <button class="preset-btn" data-label="exhaust_1" style="padding: 3px 6px; font-size: 0.8em;">Exhaust_1</button>
                                <button class="preset-btn" data-label="exhaust_2" style="padding: 3px 6px; font-size: 0.8em;">Exhaust_2</button>
                                <button class="preset-btn" data-label="exhaust_3" style="padding: 3px 6px; font-size: 0.8em;">Exhaust_3</button>
                            </div>
                            <input type="text" id="pointLabel" placeholder="Or type custom label...">
                        </div>
                        <div class="control-group">
                            <label>Canvas Size (override)</label>
                            <div style="display: flex; gap: 5px;">
                                <input type="number" id="canvasWidth" placeholder="Width" min="1" style="width: 80px;">
                                <input type="number" id="canvasHeight" placeholder="Height" min="1" style="width: 80px;">
                                <button id="applySizeBtn" style="padding: 5px 10px; font-size: 0.9em;">Apply</button>
                                <button id="resetSizeBtn" style="padding: 5px 10px; font-size: 0.9em;">Reset</button>
                            </div>
                        </div>
                        <div class="control-group">
                            <label>
                                <input type="checkbox" id="aspectLock" checked>
                                Lock Aspect Ratio (PNG)
                            </label>
                            <div style="font-size: 0.8em; color: #aaa; margin-top: 5px;">
                                Original: <span id="originalAspect">--</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Exhaust Preview Section -->
                <div class="section">
                    <h2>3.5. Exhaust Preview</h2>
                    <div class="controls">
                        <div class="control-group">
                            <label>Select Exhaust Sprite</label>
                            <select id="exhaustSelect">
                                <option value="">No exhaust preview</option>
                                <!-- Populated dynamically -->
                            </select>
                        </div>
                        <div class="control-group">
                            <label>Scale: <span id="exhaustScale" class="zoom-display">100%</span></label>
                            <input type="range" id="exhaustScaleSlider" min="25" max="200" value="100" step="5">
                        </div>
                        <div class="control-group">
                            <label>Rotation: <span id="exhaustRotation" class="zoom-display">0¬∞</span></label>
                            <input type="range" id="exhaustRotationSlider" min="0" max="360" value="0" step="5">
                        </div>
                        <div class="control-group">
                            <label>X Offset (px)</label>
                            <input type="number" id="exhaustOffsetX" value="0" step="1">
                        </div>
                        <div class="control-group">
                            <label>Y Offset (px)</label>
                            <input type="number" id="exhaustOffsetY" value="0" step="1">
                        </div>
                        <div class="control-group">
                            <label>
                                <input type="checkbox" id="exhaustPreviewToggle" checked>
                                Show Exhaust Preview
                            </label>
                        </div>
                    </div>
                </div>

                <!-- Canvas Display -->
                <div class="section">
                    <h2>4. Click to Mark Coordinates</h2>
                    <div class="canvas-wrapper">
                        <canvas id="shipCanvas"></canvas>
                    </div>
                </div>

                <!-- Status Section -->
                <div class="section">
                    <div id="status">Load a CSV and select a ship to begin</div>
                </div>
            </div>

            <!-- Point History Section -->
            <div>
                <div class="section">
                    <h2>5. Marked Points</h2>
                    <div style="margin-bottom: 10px; font-size: 0.85em; color: #aaa;">
                        <span style="color: #2ecc71;">‚óè From CSV</span> |
                        <span style="color: #ff4444;">‚óè Newly Marked</span>
                    </div>
                    <div style="margin-bottom: 10px; padding: 10px; background: #0f3460; border-radius: 4px; font-size: 0.85em; color: #aaa;">
                        <strong style="color: #4a9eff;">Workflow:</strong><br>
                        1. Export JSON ‚Üí Save to <code>tools/ship_JSONS/</code><br>
                        2. Run: <code>python3 tools/merge_ship_coordinates.py</code><br>
                        3. Reload CSV in this tool to see updated points
                    </div>
                    <ul id="pointList" class="point-list"></ul>
                    <div class="button-group">
                        <button id="exportJSON" disabled>Export to ship_JSONS/</button>
                        <button id="clearPoints" disabled>Clear New Points</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let shipData = [];
        let currentShip = null;
        let currentImage = null;
        let zoomLevel = 1.0;
        let showGrid = false;
        let markedPoints = []; // Newly marked points (red)
        let csvPoints = []; // Points loaded from CSV (green)
        let pointCounter = 0;
        let canvasSizeOverride = null; // {width, height} or null for default
        let aspectLocked = true; // Lock aspect ratio by default
        let originalAspectRatio = null; // PNG's original aspect ratio

        // Exhaust preview state
        let exhaustImage = null;          // Currently loaded exhaust Image object
        let exhaustScale = 1.0;            // Scale factor (0.25 - 2.0)
        let exhaustRotation = 0;           // Rotation in degrees (0-360)
        let exhaustOffsetX = 0;            // X offset in pixels
        let exhaustOffsetY = 0;            // Y offset in pixels
        let showExhaustPreview = true;     // Toggle preview visibility

        // Available exhaust sprites
        const exhaustSprites = [
            'assets/exhausts/s_exhaust_1_drone/s_exhaust_1_drone.png',
            'assets/exhausts/s_exhaust_2_drone/s_exhaust_2_drone.png',
            'assets/exhausts/s_exhaust_3_drone/s_exhaust_3_drone.png',
            'assets/exhausts/s_fire_double_exhaust/s_fire_double_exhaust.png',
            'assets/exhausts/s_fire_single_exhaust/s_fire_single_exhaust.png',
            'assets/exhausts/s_fire_strong_double_exhaust/s_fire_strong_double_exhaust.png',
            'assets/exhausts/s_fire_strong_single_exhaust/s_fire_strong_single_exhaust.png',
            'assets/exhausts/s_green_double_exhaust/s_green_double_exhaust.png',
            'assets/exhausts/s_green_single_exhaust/s_green_single_exhaust.png',
            'assets/exhausts/s_purple_double_exhaust/s_purple_double_exhaust.png',
            'assets/exhausts/s_purple_single_exhaust/s_purple_single_exhaust.png',
            'assets/exhausts/s_red_double_exhaust/s_red_double_exhaust.png',
            'assets/exhausts/s_red_single_exhaust/s_red_single_exhaust.png',
            'assets/exhausts/s_silver_double_exhaust/s_silver_double_exhaust.png',
            'assets/exhausts/s_silver_single_exhaust/s_silver_single_exhaust.png'
        ];

        // DOM elements
        const csvInput = document.getElementById('csvInput');
        const csvStatus = document.getElementById('csvStatus');
        const shipSelect = document.getElementById('shipSelect');
        const shipInfo = document.getElementById('shipInfo');
        const canvas = document.getElementById('shipCanvas');
        const ctx = canvas.getContext('2d');
        const zoomSlider = document.getElementById('zoomSlider');
        const zoomLevelDisplay = document.getElementById('zoomLevel');
        const gridToggle = document.getElementById('gridToggle');
        const pointLabel = document.getElementById('pointLabel');
        const pointList = document.getElementById('pointList');
        const exportJSON = document.getElementById('exportJSON');
        const clearPoints = document.getElementById('clearPoints');
        const status = document.getElementById('status');
        const canvasWidth = document.getElementById('canvasWidth');
        const canvasHeight = document.getElementById('canvasHeight');
        const applySizeBtn = document.getElementById('applySizeBtn');
        const resetSizeBtn = document.getElementById('resetSizeBtn');
        const aspectLock = document.getElementById('aspectLock');
        const originalAspect = document.getElementById('originalAspect');
        const exhaustSelect = document.getElementById('exhaustSelect');
        const exhaustScaleSlider = document.getElementById('exhaustScaleSlider');
        const exhaustScaleDisplay = document.getElementById('exhaustScale');
        const exhaustRotationSlider = document.getElementById('exhaustRotationSlider');
        const exhaustRotationDisplay = document.getElementById('exhaustRotation');
        const exhaustOffsetXInput = document.getElementById('exhaustOffsetX');
        const exhaustOffsetYInput = document.getElementById('exhaustOffsetY');
        const exhaustPreviewToggle = document.getElementById('exhaustPreviewToggle');

        // CSV Loading
        csvInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (evt) => {
                try {
                    shipData = parseCSV(evt.target.result);
                    populateShipDropdown();
                    csvStatus.textContent = `Loaded ${shipData.length} ships`;
                    showStatus('CSV loaded successfully!', 'success');
                } catch (error) {
                    showStatus('Error parsing CSV: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
        });

        // Parse CSV (handles coordinate_points JSON column)
        function parseCSV(text) {
            const lines = text.split('\n').filter(line => line.trim() && !line.trim().startsWith('#'));
            if (lines.length < 2) throw new Error('Invalid CSV format');

            const headers = parseCSVLine(lines[0]);
            const ships = [];

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];

                // Extract coordinate_points JSON more carefully
                // Find the JSON array in the line (starts with "[{" and ends with "}]")
                const jsonMatch = line.match(/"(\[.*\])"/);
                let coordinatePointsJSON = null;

                if (jsonMatch) {
                    coordinatePointsJSON = jsonMatch[1];
                }

                const values = parseCSVLine(line);

                // Skip lines that don't have enough columns (empty rows or incomplete data)
                if (values.length < 3) continue;

                const ship = {};
                headers.forEach((header, idx) => {
                    ship[header] = values[idx];
                });

                // Parse coordinate_points - use regex extraction since CSV JSON is malformed
                if (coordinatePointsJSON) {
                    try {
                        // Instead of trying to parse the malformed JSON, extract coordinates directly
                        const points = [];

                        // Split by object boundaries and process each one
                        // Pattern: find content between { and }
                        const objectRegex = /\{[^}]+\}/g;
                        const objects = coordinatePointsJSON.match(objectRegex);

                        if (objects) {
                            objects.forEach(obj => {
                                // Extract label
                                const labelMatch = obj.match(/""?label""?\s*:\s*""([^"]+)""/);
                                // Extract x coordinate (handles both "x" and ""x"" patterns)
                                const xMatch = obj.match(/""?x""?\s*:\s*"?(\d+)"?/);
                                // Extract y coordinate (handles both "y" and ""y"" patterns)
                                const yMatch = obj.match(/""?y""?\s*:\s*"?(\d+)"?/);

                                if (labelMatch && xMatch && yMatch) {
                                    points.push({
                                        label: labelMatch[1],
                                        x: parseInt(xMatch[1]),
                                        y: parseInt(yMatch[1])
                                    });
                                }
                            });
                        }

                        ship.coordinate_points = points;

                        console.log(ship.ship_ID + ': extracted ' + points.length + ' points');
                    } catch (e) {
                        console.error('Failed to extract coordinate_points for ' + ship.ship_ID + ':', e.message);
                        console.error('JSON string:', coordinatePointsJSON);
                        ship.coordinate_points = [];
                    }
                } else {
                    ship.coordinate_points = [];
                }

                // Only include ships with existing sprites
                if (ship.sprite_exists === 'TRUE') {
                    ships.push(ship);
                }
            }

            return ships;
        }

        // Properly parse CSV line handling quoted fields
        function parseCSVLine(line) {
            const values = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const nextChar = i + 1 < line.length ? line[i + 1] : null;

                if (char === '"') {
                    if (inQuotes && nextChar === '"') {
                        // Escaped quote ("") - add one quote to current value
                        current += '"';
                        i++; // Skip next quote
                    } else {
                        // Toggle quote state
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    // Field separator (only when not inside quotes)
                    values.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }

            // Add last value
            values.push(current.trim());
            return values;
        }

        // Populate ship dropdown
        function populateShipDropdown() {
            shipSelect.innerHTML = '<option value="">Select a ship...</option>';
            shipData.forEach((ship, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `${ship.ship_ID} (${ship.sprite_width}√ó${ship.sprite_height})`;
                shipSelect.appendChild(option);
            });
            shipSelect.disabled = false;
        }

        // Ship selection
        shipSelect.addEventListener('change', (e) => {
            const index = e.target.value;
            if (!index) return;

            currentShip = shipData[index];
            loadShipSprite(currentShip);
            displayShipInfo(currentShip);
            clearMarkedPoints();
            loadCsvPoints(currentShip);
        });

        // Display ship info
        function displayShipInfo(ship, imgNaturalWidth = null, imgNaturalHeight = null, scaleFactor = null) {
            shipInfo.style.display = 'block';
            let sizeInfo = `<strong>Godot Display Size:</strong> ${ship.sprite_width}√ó${ship.sprite_height}px`;

            if (imgNaturalWidth && imgNaturalHeight) {
                sizeInfo += `<br><strong>PNG Actual Size:</strong> ${imgNaturalWidth}√ó${imgNaturalHeight}px`;

                if (imgNaturalWidth !== parseInt(ship.sprite_width) || imgNaturalHeight !== parseInt(ship.sprite_height)) {
                    sizeInfo += ` <span style="color: #ffaa44;">‚ö† Will be scaled in Godot</span>`;
                }
            }

            if (scaleFactor !== null) {
                sizeInfo += `<br><strong>Scale Factor:</strong> ${scaleFactor.toFixed(4)} <span style="color: #aaa;">(PNG ‚Üí Godot)</span>`;
            }

            shipInfo.innerHTML = `
                <strong>Ship ID:</strong> ${ship.ship_ID}<br>
                ${sizeInfo}<br>
                <strong>Canvas Size:</strong> ${canvas.width}√ó${canvas.height}px <span style="color: #4a9eff;">(Marking space)</span><br>
                <strong>Path:</strong> ${ship.sprite_path}
            `;
        }

        // Load ship sprite
        function loadShipSprite(ship) {
            const img = new Image();

            // Convert Godot path to relative path
            let path = ship.sprite_path.replace('res://', '../../');

            img.onload = () => {
                currentImage = img;

                // Store original aspect ratio
                originalAspectRatio = img.naturalWidth / img.naturalHeight;
                if (originalAspect) {
                    originalAspect.textContent = `${img.naturalWidth}√ó${img.naturalHeight} (${originalAspectRatio.toFixed(3)})`;
                }

                // Default to full PNG resolution
                let width = canvasSizeOverride ? canvasSizeOverride.width : img.naturalWidth;
                let height = canvasSizeOverride ? canvasSizeOverride.height : img.naturalHeight;

                // Apply aspect lock if enabled
                if (aspectLocked && canvasSizeOverride) {
                    height = Math.round(width / originalAspectRatio);
                }

                // Calculate scale factor
                const calculatedScaleFactor = parseInt(ship.sprite_width) / img.naturalWidth;

                canvas.width = width;
                canvas.height = height;

                // Update size input fields to show current size
                canvasWidth.value = width;
                canvasHeight.value = height;

                // Update ship info with actual PNG dimensions and scale factor
                displayShipInfo(ship, img.naturalWidth, img.naturalHeight, calculatedScaleFactor);

                redrawCanvas();
                showStatus(`Loaded: ${ship.ship_ID} (PNG: ${img.naturalWidth}√ó${img.naturalHeight}, Scale: ${calculatedScaleFactor.toFixed(4)})`, 'success');
            };

            img.onerror = () => {
                showStatus(`Failed to load image: ${path}`, 'error');
            };

            img.src = path;
        }

        // Redraw canvas
        function redrawCanvas() {
            if (!currentImage) return;

            const scaledWidth = canvas.width * zoomLevel;
            const scaledHeight = canvas.height * zoomLevel;

            canvas.style.width = scaledWidth + 'px';
            canvas.style.height = scaledHeight + 'px';

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw image scaled to canvas size
            ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);

            // Draw exhaust sprites at exhaust points
            if (exhaustImage && showExhaustPreview) {
                drawExhaustPreviews();
            }

            // Draw grid if enabled
            if (showGrid) {
                drawGrid();
            }

            // Redraw CSV points (green)
            csvPoints.forEach(point => {
                drawMarker(point.x, point.y, point.label, false, '#2ecc71');
            });

            // Redraw marked points (red)
            markedPoints.forEach(point => {
                drawMarker(point.x, point.y, point.label, false, '#ff4444');
            });
        }

        // Draw pixel grid
        function drawGrid() {
            ctx.strokeStyle = 'rgba(74, 158, 255, 0.3)';
            ctx.lineWidth = 1;

            // Vertical lines
            for (let x = 0; x <= canvas.width; x++) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            // Horizontal lines
            for (let y = 0; y <= canvas.height; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        // Draw exhaust previews at all exhaust points
        function drawExhaustPreviews() {
            if (!exhaustImage) return;

            // Collect all exhaust points from both CSV and newly marked points
            const allPoints = [...csvPoints, ...markedPoints];

            // Filter for exhaust points only (exhaust_1, exhaust_2, exhaust_3)
            const exhaustPoints = allPoints.filter(point =>
                point.label.startsWith('exhaust_')
            );

            // Draw exhaust sprite at each exhaust point
            exhaustPoints.forEach(point => {
                drawExhaustAtPoint(point.x, point.y);
            });
        }

        // Draw exhaust sprite at a specific point
        function drawExhaustAtPoint(x, y) {
            ctx.save();

            // Apply offsets to position
            const drawX = x + exhaustOffsetX;
            const drawY = y + exhaustOffsetY;

            // Move to the exhaust point
            ctx.translate(drawX, drawY);

            // Apply rotation (convert degrees to radians)
            ctx.rotate(exhaustRotation * Math.PI / 180);

            // Apply scale
            ctx.scale(exhaustScale, exhaustScale);

            // Draw exhaust with origin at right-center
            // Origin on right side (x = 0) and vertically centered (y = -height/2)
            const exhaustWidth = exhaustImage.naturalWidth;
            const exhaustHeight = exhaustImage.naturalHeight;

            ctx.drawImage(
                exhaustImage,
                -exhaustWidth,              // X: Right edge at origin
                -exhaustHeight / 2,         // Y: Vertically centered
                exhaustWidth,
                exhaustHeight
            );

            ctx.restore();
        }

        // Draw marker
        function drawMarker(x, y, label, animate = true, color = '#ff4444') {
            // Draw crosshair
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;

            ctx.beginPath();
            ctx.moveTo(x - 5, y);
            ctx.lineTo(x + 5, y);
            ctx.moveTo(x, y - 5);
            ctx.lineTo(x, y + 5);
            ctx.stroke();

            // Draw label with zoom-adjusted font size
            if (label) {
                ctx.fillStyle = color;
                // Scale font size inversely with zoom to keep it readable
                const fontSize = Math.max(8, Math.min(14, 10 / zoomLevel));
                ctx.font = `bold ${fontSize}px monospace`;
                const offset = 7 / zoomLevel;
                ctx.fillText(label, x + offset, y - offset);
            }
        }

        // Canvas click handler
        canvas.addEventListener('click', (e) => {
            if (!currentImage) return;

            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / zoomLevel);
            const y = Math.floor((e.clientY - rect.top) / zoomLevel);

            // Get label or generate one
            const label = pointLabel.value.trim() || `point_${pointCounter++}`;
            const coordStr = `${x},${y}`;

            // Copy to clipboard
            copyToClipboard(coordStr);

            // Add point
            addMarkedPoint(label, x, y);

            // Redraw canvas
            redrawCanvas();

            // Show status
            showStatus(`Copied: ${label} = (${x}, ${y})`, 'success');

            // Clear label input
            pointLabel.value = '';
        });

        // Add marked point
        function addMarkedPoint(label, x, y) {
            markedPoints.push({ label, x, y });
            updatePointList();
            exportJSON.disabled = false;
            clearPoints.disabled = false;
        }

        // Load points from CSV
        function loadCsvPoints(ship) {
            csvPoints = [];
            if (ship.coordinate_points && ship.coordinate_points.length > 0) {
                csvPoints = ship.coordinate_points.map(p => ({
                    label: p.label,
                    x: p.x,
                    y: p.y
                }));
                showStatus(`Loaded ${csvPoints.length} points from CSV`, 'success');
            }
            updatePointList();
            redrawCanvas();
        }

        // Update point list display
        function updatePointList() {
            pointList.innerHTML = '';

            // Show CSV points (green)
            if (csvPoints.length > 0) {
                const header = document.createElement('li');
                header.style.cssText = 'background: #0f3460; color: #2ecc71; font-weight: bold; padding: 5px; margin-bottom: 5px;';
                header.textContent = `From CSV (${csvPoints.length})`;
                pointList.appendChild(header);

                csvPoints.forEach((point, index) => {
                    const li = document.createElement('li');
                    li.className = 'point-item';
                    li.style.borderLeft = '3px solid #2ecc71';
                    li.innerHTML = `
                        <span class="point-label" style="color: #2ecc71">${point.label}</span>
                        <span class="point-coords">(${point.x}, ${point.y})</span>
                        <button class="point-remove" onclick="removeCsvPoint(${index})">Remove</button>
                    `;
                    pointList.appendChild(li);
                });
            }

            // Show new marked points (red)
            if (markedPoints.length > 0) {
                const header = document.createElement('li');
                header.style.cssText = 'background: #0f3460; color: #ff4444; font-weight: bold; padding: 5px; margin-bottom: 5px; margin-top: 10px;';
                header.textContent = `Newly Marked (${markedPoints.length})`;
                pointList.appendChild(header);

                markedPoints.forEach((point, index) => {
                    const li = document.createElement('li');
                    li.className = 'point-item';
                    li.style.borderLeft = '3px solid #ff4444';
                    li.innerHTML = `
                        <span class="point-label" style="color: #ff4444">${point.label}</span>
                        <span class="point-coords">(${point.x}, ${point.y})</span>
                        <button class="point-remove" onclick="removePoint(${index})">Remove</button>
                    `;
                    pointList.appendChild(li);
                });
            }

            // Update button states
            const hasPoints = markedPoints.length > 0 || csvPoints.length > 0;
            exportJSON.disabled = !hasPoints;
            clearPoints.disabled = markedPoints.length === 0;
        }

        // Remove point
        window.removePoint = function(index) {
            markedPoints.splice(index, 1);
            updatePointList();
            redrawCanvas();
        };

        // Remove CSV point
        window.removeCsvPoint = function(index) {
            csvPoints.splice(index, 1);
            updatePointList();
            redrawCanvas();
        };

        // Clear all points
        clearPoints.addEventListener('click', () => {
            clearMarkedPoints();
        });

        function clearMarkedPoints() {
            markedPoints = [];
            pointCounter = 0;
            updatePointList();
            redrawCanvas();
            exportJSON.disabled = true;
            clearPoints.disabled = true;
        }

        // Export to JSON (combines CSV points and new points)
        exportJSON.addEventListener('click', () => {
            if (!currentShip) return;

            const allPoints = [...csvPoints, ...markedPoints];
            if (allPoints.length === 0) return;

            const scaleFactor = currentImage ? (parseInt(currentShip.sprite_width) / currentImage.naturalWidth) : null;

            const exportData = {
                ship_id: currentShip.ship_ID,
                png_size: currentImage ? {
                    width: currentImage.naturalWidth,
                    height: currentImage.naturalHeight
                } : null,
                sprite_size: {
                    width: parseInt(currentShip.sprite_width),
                    height: parseInt(currentShip.sprite_height)
                },
                canvas_size: {
                    width: canvas.width,
                    height: canvas.height
                },
                scale_factor: scaleFactor ? parseFloat(scaleFactor.toFixed(4)) : null,
                points: allPoints
            };

            const json = JSON.stringify(exportData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentShip.ship_ID}_points.json`;
            a.click();

            URL.revokeObjectURL(url);
            showStatus(`Exported ${allPoints.length} points (scale: ${scaleFactor ? scaleFactor.toFixed(4) : 'N/A'})`, 'success');
        });

        // Zoom controls
        zoomSlider.addEventListener('input', (e) => {
            zoomLevel = e.target.value / 100;
            zoomLevelDisplay.textContent = `${e.target.value}%`;
            redrawCanvas();
        });

        // Grid toggle
        gridToggle.addEventListener('change', (e) => {
            showGrid = e.target.checked;
            redrawCanvas();
        });

        // Aspect lock toggle
        aspectLock.addEventListener('change', (e) => {
            aspectLocked = e.target.checked;
        });

        // Canvas size override
        applySizeBtn.addEventListener('click', () => {
            let width = parseInt(canvasWidth.value);
            let height = parseInt(canvasHeight.value);

            if (isNaN(width) || width < 1) {
                showStatus('Invalid width', 'error');
                return;
            }

            if (aspectLocked && originalAspectRatio) {
                height = Math.round(width / originalAspectRatio);
                canvasHeight.value = height;
            } else if (isNaN(height) || height < 1) {
                showStatus('Invalid height', 'error');
                return;
            }

            canvasSizeOverride = { width, height };

            if (currentImage && currentShip) {
                canvas.width = width;
                canvas.height = height;
                redrawCanvas();
                showStatus(`Canvas resized to ${width}√ó${height}`, 'success');
            }
        });

        resetSizeBtn.addEventListener('click', () => {
            canvasSizeOverride = null;

            if (currentImage && currentShip) {
                const width = currentImage.naturalWidth;
                const height = currentImage.naturalHeight;
                canvas.width = width;
                canvas.height = height;
                canvasWidth.value = width;
                canvasHeight.value = height;
                redrawCanvas();
                showStatus('Canvas reset to full PNG resolution', 'success');
            }
        });

        // Copy to clipboard
        function copyToClipboard(text) {
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).catch(err => {
                    console.error('Failed to copy:', err);
                    fallbackCopy(text);
                });
            } else {
                fallbackCopy(text);
            }
        }

        // Fallback copy method
        function fallbackCopy(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
            } catch (err) {
                console.error('Fallback copy failed:', err);
            }
            document.body.removeChild(textarea);
        }

        // Show status
        function showStatus(message, type = '') {
            status.textContent = message;
            status.className = '';
            if (type === 'success') {
                status.classList.add('status-success');
            } else if (type === 'error') {
                status.classList.add('status-error');
            }
        }

        // Preset buttons
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                const label = btn.getAttribute('data-label');
                pointLabel.value = label;

                // Highlight active preset
                document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                showStatus(`Preset selected: ${label}`, 'success');
            });
        });

        // Clear preset highlight when typing custom label
        pointLabel.addEventListener('input', () => {
            document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ctrl+Z to remove last point
            if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                if (markedPoints.length > 0) {
                    removePoint(markedPoints.length - 1);
                }
            }
            // R to reset zoom
            if (e.key === 'r' || e.key === 'R') {
                zoomSlider.value = 100;
                zoomLevel = 1.0;
                zoomLevelDisplay.textContent = '100%';
                redrawCanvas();
            }
        });

        // Populate exhaust dropdown
        function initializeExhaustDropdown() {
            exhaustSprites.forEach(path => {
                const option = document.createElement('option');
                option.value = path;
                // Extract friendly name: "s_fire_single_exhaust.png" -> "Fire Single"
                const filename = path.split('/').pop().replace('.png', '');
                const displayName = filename
                    .replace('s_', '')
                    .split('_')
                    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                    .join(' ');
                option.textContent = displayName;
                exhaustSelect.appendChild(option);
            });
        }

        // Exhaust selection event handler
        exhaustSelect.addEventListener('change', (e) => {
            if (!e.target.value) {
                exhaustImage = null;
                redrawCanvas();
                return;
            }

            const img = new Image();
            img.onload = () => {
                exhaustImage = img;
                redrawCanvas();
                showStatus(`Loaded exhaust: ${img.naturalWidth}√ó${img.naturalHeight}px`, 'success');
            };
            img.onerror = () => {
                showStatus(`Failed to load exhaust: ${e.target.value}`, 'error');
                exhaustImage = null;
            };
            // Convert path for web access (relative from HTML file location)
            img.src = '../../' + e.target.value;
        });

        // Exhaust scale control
        exhaustScaleSlider.addEventListener('input', (e) => {
            exhaustScale = e.target.value / 100;
            exhaustScaleDisplay.textContent = `${e.target.value}%`;
            redrawCanvas();
        });

        // Exhaust rotation control
        exhaustRotationSlider.addEventListener('input', (e) => {
            exhaustRotation = parseInt(e.target.value);
            exhaustRotationDisplay.textContent = `${e.target.value}¬∞`;
            redrawCanvas();
        });

        // Exhaust offset controls
        exhaustOffsetXInput.addEventListener('input', (e) => {
            exhaustOffsetX = parseInt(e.target.value) || 0;
            redrawCanvas();
        });

        exhaustOffsetYInput.addEventListener('input', (e) => {
            exhaustOffsetY = parseInt(e.target.value) || 0;
            redrawCanvas();
        });

        // Exhaust preview toggle
        exhaustPreviewToggle.addEventListener('change', (e) => {
            showExhaustPreview = e.target.checked;
            redrawCanvas();
        });

        // Initialize exhaust dropdown on page load
        initializeExhaustDropdown();
    </script>
</body>
</html>
